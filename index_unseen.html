<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Unseen Phapsody</title>
  <!-- 添加一个空 favicon 避免加载本地文件错误 -->
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.js"></script>
  <style>
    body {
        font-family: 'Avenir';
        background-color: #FCFAF2;
        color: #080808;
        margin: 20px;
        display: flex;
        flex-direction: column;
        justify-content: center;  /* 垂直居中 */
        align-items: center;      /* 水平居中 */
        min-height: 100vh;        /* 至少占满整个视口高度 */
        text-align: center;       /* 文字居中 */
    }
    .wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: calc(100vh - 40px);
      width: 100%;
    }
    .content {
      flex: 1;
      padding: 40px 20px 20px 20px;
    }
    /* footer 固定在页面最下方 */
    footer {
        margin-top: auto;  /* 自动填充顶部空间，将 footer 推到底部 */
        width: 100%;
        text-align: center;
        font-size: 9px;
        color: #555;
        padding: 10px 0;
    }
    #sidebar {
      font-family: 'Avenir';
      height: calc(100vh - 40px);
      width: 250px;
      position: fixed;
      left: -270px;
      top: 0;
      background-color: #434343;
      overflow-x: hidden;
      transition: 0.5s;
      padding-top: 60px;
      z-index: 2;
      display: flex;
      flex-direction: column;
      box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2);
      padding-bottom: 60px;  /* 例如底部再增加40px内边距 */
    }
    /* 上半部分导航 */
    .nav-top ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    /* 下半部分导航 */
    .nav-bottom {
      margin-top: auto;  /* 将 nav-bottom 推到最底部 */
      margin-bottom: 60px;  /* 在底部再留出20px的间距 */
    }

    .nav-bottom ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    /* 设置 contact 项的字体较小 */
    .nav-bottom ul li.contact a {
      font-size: 0.7em;  /* 例如 70% 的默认字号 */
    }
    #sidebar ul {
      list-style-type: none;
      padding: 0;
    }
    #sidebar ul li {
      padding: 8px 8px 8px 32px;
      text-align: left;
    }
    #sidebar ul li a {
      color: #fff;
      text-decoration: none;
      display: block;
    }
    #sidebar ul li a:hover {
      background-color: #434343;
    }
    #openSidebar {
      position: fixed;
      top: 20px;
      left: 20px;
      font-size: 30px;
      background: none;
      border: none;
      color: #434343;
      cursor: pointer;
      z-index: 3;
    }
    /* 弹出框（Modal）样式 */
    .modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      width: 400px;
      height: 600px;
      background-color: #fff;
      box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
      border-radius: 8px; /* 无圆角 */
      padding: 20px;
      position: relative;
      display: flex;
      flex-direction: column;
    }
    .modal-content .scrollContainer {
      font-size: 14px;
      overflow-y: auto;
      flex: 1;
      text-align: left;
    }
    .modal-content p {
      margin: 5px 0;
    }
    .modal-content .centerContent {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      font-size: 14px;
    }
    .modal-content .close {
      position: absolute;
      top: 14px;
      right: 10px;
      font-size: 24px;
      cursor: pointer;
    }
    #closeSidebar {
      position: absolute;
      top: 20px;
      right: 25px;
      font-size: 36px;
      background: none;
      border: none;
      color: #FCFAF2;
      cursor: pointer;
    }
    #imageCanvas {
        border-radius: 4px;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        border: 1px solid #ccc;
        margin-top: 10px;
        cursor: crosshair;
        display: block; /* 确保是 block 级别以便 margin auto 生效 */
    }
    #lilypondContainer {
        margin-top: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #lilypondCode {
      background-color: #f7f7f7;
      border: 1px solid #ccc;
      padding: 10px;
      white-space: pre-wrap;
      font-family: Consolas, monospace;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* 隐藏文件输入框（移出视口） */
    #imageUpload {
      position: absolute;
      left: -9999px;
    }
    .custom-file-upload {
      font-family: 'Avenir';
      display: inline-block;
      width: 150px;      /* 固定宽度 */
      height: 50px;      /* 固定高度 */
      line-height: 50px; /* 设置行高，使文字垂直居中 */
      text-align: center;/* 文字水平居中 */
      padding: 0;        /* 如果设置了固定高度，通常需要取消内边距 */
      cursor: pointer;
      border: 2px solid #074D8F;
      border-radius: 8px;
      background-color: #074D8F;
      color: #fff;
      font-size: 16px;
      transition: background-color 0.3s, border-color 0.3s;
      box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
      margin-top: 5px; /* 避免与侧边栏按钮重叠 */
      margin-right: 50px;
      margin-left: 50px;
    }
    .custom-file-upload:hover {
      background-color: #113b68;
      border-color: #113b68;
    }
    .btn {
      font-family: 'Avenir';
      display: inline-block;
      width: 150px;      /* 固定宽度 */
      height: 50px;      /* 固定高度 */
      line-height: 50px; /* 设置行高，使文字垂直居中 */
      text-align: center;/* 文字水平居中 */
      padding: 0;        /* 如果设置了固定高度，通常需要取消内边距 */
      cursor: pointer;
      border: 2px solid #434343;
      border-radius: 8px;
      background-color: #434343;
      color: #fff;
      font-size: 16px;
      margin-right: 50px;
      margin-top: 5px;
      margin-left: 50px;
      transition: background-color 0.3s, border-color 0.3s;
      box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
    }
    .btn:hover {
      background-color: #1C1C1C;
      border-color: #1C1C1C;
    }
    /* 初始隐藏 canvas , Clear 按钮 和 LilyPond Source Code */
    #imageCanvas, #clearButton, #lilypondCode {
      display: none;
    }
    /* 针对屏幕宽度较小的设备进行调整 */
    @media only screen and (max-width: 800px) {
      body {
        font-size: 18px; /* 增大整体文字大小 */
        margin: 0;
      }
      .wrapper {
        min-height: 100vh;
      }
      .modal-content {
        width: calc(100vw - 100px); /* 手机屏幕宽度减去100px */
        height: 600px;
      }
      .btn {
        margin: 10px 20px;    /* 调整按钮的外边距 */
      }
      .custom-file-upload {
        margin: 10px 20px;    /* 调整按钮的外边距 */
      }
      #imageCanvas, #lilypondContainer, #lilypondCode {
        width: calc(100vw - 50px);
      }
      #sidebar {
        height: calc(100vh - 40px);
        padding-bottom: 100px;  /* 减少内边距 */
        /* 如果内容太多，也可以添加滚动条 */
        overflow-y: auto;
      }
      /* 调整底部导航的外边距 */
      .nav-bottom {
        margin-top: auto;  /* 保持推到底部 */
        margin-bottom: 200px;  /* 减少底部留白 */
      }
      footer {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        background-color: #fff;
        z-index: 100;
      }
    }
  </style>
</head>
<body>
<div class="wrapper">
        <div id="sidebar">
  <button id="closeSidebar">&times;</button>
  <div class="nav-top">
    <ul>
      <li><a href="#" id="nav-top">TOP</a></li>
      <li><a href="index.html" id="nav-blossound"><b>Blossound</b></a></li>
      <li><a href="index_unseen.html" id="nav-unseen"><b>Unseen Rhapsody</b></a></li>
    </ul>
  </div>
  <div class="nav-bottom">
    <ul>
      <li class="contact"><a href="#" id="nav-contact">Contact Us</a></li>
      <li class="contact"><a href="#" id="nav-faq">FAQ</a></li>
      <li class="contact"><a href="#" id="nav-future">Future Visions</a></li>
    </ul>
  </div>
</div>
        <button id="openSidebar">&#9776;</button>
  <div class="content">
  <h1>Unseen Rhapsody</h1>
  <p>Hearing the colors unseen</p>
  <label for="imageUpload" class="custom-file-upload">
    <b>SELECT IMAGE</b>
  </label>
  <input type="file" id="imageUpload" accept="image/*" />
  <br>
  <canvas id="imageCanvas"></canvas>
  <br>
  <button id="clearButton" class="btn"><b>CLEAR ALL</b></button>
  
  <div id="lilypondContainer"></div>
  <!-- <h3>LilyPond Source Code</h3> -->
  <pre id="lilypondCode"></pre>

</div>
  <footer>
    © 2025 Blossound. All rights reserved.
  </footer>
</div>

 <!-- 弹出框 -->
 <div id="modal" class="modal">
    <div class="modal-content">
    </div>
  </div>
  
  <!-- 引入 VexFlow 库 -->
  <script src="https://unpkg.com/vexflow/releases/vexflow-debug.js"></script>
  
  <script>

    /* 导航侧边栏的开关 */
    const openSidebar = document.getElementById('openSidebar');
    const closeSidebar = document.getElementById('closeSidebar');
    const sidebar = document.getElementById('sidebar');
    
    openSidebar.addEventListener('click', () => {
      sidebar.style.left = "0";
    });
    
    closeSidebar.addEventListener('click', () => {
      sidebar.style.left = "-250px";
    });
    
    /* 弹出框功能 */
    const modal = document.getElementById('modal');
    const modalContentContainer = document.querySelector('.modal-content');
    
    function openModal() {
      modal.style.display = "flex";
    }
    
    function closeModal() {
      modal.style.display = "none";
    }
    
    // 关闭按钮事件（需在每次设置内容后绑定）
  function bindModalClose() {
    document.getElementById('modalClose').addEventListener('click', closeModal);
  }
  
  // 当点击 TOP 时，显示三段长文本，文字字号10px，内容可滚动
  document.getElementById('nav-top').addEventListener('click', (e) => {
    e.preventDefault();
    modalContentContainer.innerHTML =
      '<span class="close" id="modalClose">&times;</span>' +
      '<div class="scrollContainer">' +
        '<h2>INTRODUCTION</h2><br>' +
        '<p>Have you ever stood in a museum or art exhibition, gazing at a masterpiece yet feeling unable to truly enter the artist’s world—perhaps due to a language barrier? Or maybe you’ve wanted to bring your parents or friends along, only to realize some are visually impaired and can only listen to others describe the beauty they cannot see for themselves? Wouldn’t it be wonderful if we could transform images into <strong>sound</strong>, allowing our eyes and ears to discover the wonders of art together?</p><br><br>' +
        '<p>With these thoughts in mind, I had a bold idea: what if we could interpret images through music, letting the colors and emotions of a painting blossom into a melody in our minds? Could this enable visually impaired individuals to <strong>hear</strong> the essence of a painting, while giving all of us a deeper understanding of the work? Driven by this question, I created a small <strong>image-to-sound</strong> project. Simply upload a photo, and the system automatically generates a unique piano melody and score—bestowing each still image with its own <strong>background song</strong>.</p><br><br>' +
        '<p>To give you a taste of this cross-boundary exploration:</p><br><br>' +
        '<p>I.   Photos taken at the same place, but in different seasons or weather, might translate into completely distinct sets of notes—allowing you to <strong>hear</strong> the contrast between the vitality of spring and the melancholy of autumn.</p><br>' +
        '<p>II.  In a museum, a Monet or Van Gogh painting could be rendered into a melody, so you can <strong>hear</strong> its colors while admiring the brushstrokes.</p><br>' +
        '<p>III. Traveling with family or friends? Snap a memorable photo, then instantly generate a <strong>spontaneous photo soundtrack</strong>, preserving both the image and its music as a one-of-a-kind memento.</p><br>' +
        '<p>I hope this <strong>sonic visualization</strong> approach will offer a fresh perspective for more people to appreciate art, especially those who may not be able to see it themselves. And for those with no composition experience, this project might reveal how a single photograph can inspire a marvelous musical connection. Every click of the shutter is like the world searching for its theme song. May you find, in this project, a chance to hear the distinct tune that belongs to both you and the image before you?</p><br><br>' +
      '</div>';
    bindModalClose();
    openModal();
  });
  
  // 当点击 Contact Us 时，弹出框中显示 “e-mail address”
  document.getElementById('nav-contact').addEventListener('click', (e) => {
    e.preventDefault();
    modalContentContainer.innerHTML =
      '<span class="close" id="modalClose">&times;</span>' +
      '<div class="scrollContainer">' +
        '<h2>CONTACT BLOSSOUND</h2>' +
        '<p><i>Where Colors Find Their Voice</i></p><br><br>' +
        '<p>We believe every image holds a hidden melody waiting to be heard. Whether you’re an artist exploring sonic landscapes, a museum curator reimagining accessibility, or simply someone who just saw a sunset that deserves its own soundtrack – we want to hear from you.</p><br><br><br><br>' + 
        '<p><strong>Let’s Create Harmony Together:</strong></p>' +
        '<p><i>General Inquires</i>: yaoyao.demi0420@gmail.com</p>' +
        '<p>We read every message and respond within 72 hours.</p><br><br>' +
        '<p align="center">"<i>The world whispers in colors, <br>and we’re here to amplify their song.</i>"</p><br><br>' +
      '</div>';
    bindModalClose();
    openModal();
  });
  
  // 当点击 FAQ 时，弹出框中显示 “Answers”
  document.getElementById('nav-faq').addEventListener('click', (e) => {
    e.preventDefault();
    modalContentContainer.innerHTML =
      '<span class="close" id="modalClose">&times;</span>' +
      '<div class="centerContent">' +
        '<p>We will collect questions and list the answers here.</p>' +
      '</div>';
    bindModalClose();
    openModal();
  });

    // 当点击 FAQ 时，弹出框中显示 “Answers”
    document.getElementById('nav-future').addEventListener('click', (e) => {
    e.preventDefault();
    modalContentContainer.innerHTML =
      '<span class="close" id="modalClose">&times;</span>' +
      '<div class="scrollContainer">' +
        '<h2>Towards Unseen Rhapsody</h2>' +
        '<p><i>Hearing the colors unseen</i></p><br><br>' +
        '<p>At Blossound, we’re crafting a world where art transcends the boundaries of light. We are currently:</p><br>' + 
        '<p>I.  Developing haptic-sound interfaces that empower fingertips to see melodies</p><br>' +
        '<p>II. Co-creating immersive, multi-sensory gallery experiences with blind musicians.</p><br><br>' +
      '</div>';
    bindModalClose();
    openModal();
  });
  
  // 点击弹出框背景关闭弹出框
  window.addEventListener('click', (e) => {
    if (e.target === modal) {
      closeModal();
    }
  });
    /******************************************
     * 预定义调性映射
     ******************************************/
    const COLOR_TONE_DICT = {
        "#FFFFFF": "C-b",  
        "#000000": "C-s",  
        "#FFFDD0": "#C-b", 
        "#8B0000": "#C-s",
        "#008000": "D-b",  
        "#013220": "d-s",  
        "#FFFFE0": "bE-b", 
        "#7FFF00": "be-s",
        "#FFFF00": "E-b", 
        "#00008B": "e-s", 
        "#FFDAB9": "F-b", 
        "#4B0082": "f-s", 
        "#FF0000": "#F-b",
        "#191970": "#f-s",
        "#FFA500": "G-b", 
        "#1E90FF": "g-s", 
        "#B8860B": "bA-b", 
        "#ADD8E6": "#g-s",
        "#FFD700": "A-b",  
        "#0000FF": "a-s", 
        "#FFB6C1": "bB-b",
        "#654321": "bb-s",
        "#C0C0C0": "B-b",  
        "#696969": "b-s" 
    };
    
    const COLOR_TO_TONE_MAP = {
        "C-b": {
            "description": "#FFFFFF", 
            "tempo": 85,
            "key": "C",
            "scale_mode": "major",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["C", "D", "E", "F", "G", "A", "B", "C"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["C", "F", "G", "C"]
        },
        "C-s": {
            "description": "#000000", 
            "tempo": 85,
            "key": "C",
            "scale_mode": "minor",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["C", "D", "Eb", "F", "G", "Ab", "Bb", "C"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["Cm", "Fm", "G", "Cm"]
        },
        "#C-b": {
            "description": "#FFFDD0", 
            "tempo": 85,
            "key": "C#",
            "scale_mode": "major",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["C#", "D#", "E#", "F#", "G#", "A#", "B#", "C#"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["C#", "F#", "G#", "C#"]
        },
        "#C-s": {
            "description": "#8B0000", 
            "tempo": 85,
            "key": "C#",
            "scale_mode": "minor",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["C#", "D#", "E", "F#", "G#", "A", "B", "C#"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["C#m", "F#m", "G#", "C#m"]
        },
        "D-b": {
            "description": "#008000", 
            "tempo": 85,
            "key": "D",
            "scale_mode": "major",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["D", "E", "F#", "G", "A", "B", "C#", "D"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["D", "G", "A", "D"]
        },
        "d-s": {
            "description": "#013220", 
            "tempo": 85,
            "key": "D",
            "scale_mode": "minor",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["D", "E", "F", "G", "A", "Bb", "C", "D"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["Dm", "Gm", "A", "Dm"]
        },
        "bE-b": {
            "description": "#FFFFE0", 
            "tempo": 85,
            "key": "Eb",
            "scale_mode": "major",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["E-", "F", "G", "Ab", "Bb", "C", "D", "Eb"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["Eb", "Ab", "Bb", "Eb"]
        },
        "be-s": {
            "description": "#7FFF00", 
            "tempo": 85,
            "key": "Eb",
            "scale_mode": "minor",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["Eb", "F", "Gb", "Ab", "Bb", "Cb", "Db", "Eb"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["Ebm", "Abm", "Bb", "Ebm"]
        },
        "E-b": {
            "description": "#FFFF00", 
            "tempo": 85,
            "key": "E",
            "scale_mode": "major",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["E", "F#", "G#", "A", "B", "C#", "D#", "E"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["E", "A", "B", "E"],
        },
        "e-s": {
            "description": "#00008B", 
            "tempo": 85,
            "key": "E",
            "scale_mode": "minor",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["E", "F#", "G", "A", "B", "C", "D", "E"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["Em", "Am", "B", "Em"]
        },
        "F-b": {
            "description": "#FFDAB9", 
            "tempo": 85,
            "key": "F",
            "scale_mode": "major",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["F", "G", "A", "Bb", "C", "D", "E", "F"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["F", "Bb", "C", "F"]
        },
        "f-s": {
            "description": "#4B0082", 
            "tempo": 85,
            "key": "F",
            "scale_mode": "minor",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["F", "G", "Ab", "Bb", "C", "Db", "Eb", "F"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["Fm", "Bbm", "C", "Fm"]
        },
        "#F-b": {
            "description": "#FF0000", 
            "tempo": 85,
            "key": "F#",
            "scale_mode": "major",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["F#", "G#", "A#", "B", "C#", "D#", "E#", "F#"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["F#", "B", "C#", "F#"]
        },
        "#f-s": {
            "description": "#191970",
            "tempo": 85,
            "key": "F#",
            "scale_mode": "minor",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["F#", "G#", "A", "B", "C#", "D", "E", "F#"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["F#m", "Bm", "C#", "F#m"]
        },
        "G-b": {
            "description": "#FFA500", 
            "tempo": 85,
            "key": "G",
            "scale_mode": "major",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["G", "A", "B", "C", "D", "E", "F#", "G"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["G", "C", "D", "G"],
        },
        "g-s": {
            "description": "#1E90FF",
            "tempo": 85,
            "key": "G",
            "scale_mode": "minor",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["G", "A", "Bb", "C", "D", "Eb", "F", "G"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["Gm", "Cm", "D", "Gm"]
        },
        "bA-b": {
            "description": "#B8860B", 
            "tempo": 85,
            "key": "Ab",
            "scale_mode": "major",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["Ab", "Bb", "C", "Db", "Eb", "F", "G", "Ab"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["Ab", "Db", "Eb", "Ab"]
        },
        "#g-s": {
            "description": "#ADD8E6", 
            "tempo": 85,
            "key": "G#",
            "scale_mode": "minor",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["G#", "A#", "B", "C#", "D#", "E#", "F#", "G#"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["G#m", "C#m", "D#", "G#m"]
        },
        "A-b": {
            "description": "#FFD700", 
            "tempo": 85,
            "key": "A",
            "scale_mode": "major",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["A", "B", "C#", "D", "E", "F#", "G#", "A"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["A", "D", "E", "A"]
        },
        "a-s": {
            "description": "#0000FF", 
            "tempo": 85,
            "key": "A",
            "scale_mode": "minor",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["A", "B", "C", "D", "E", "F", "G", "A"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["Am", "Dm", "E", "Am"]
        },
        "bB-b": {
            "description": "#FFB6C1", 
            "tempo": 85,
            "key": "Bb",
            "scale_mode": "major",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["Bb", "C", "D", "Eb", "F", "G", "A", "Bb"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["Bb", "Eb", "F", "Bb"]
        },
        "bb-s": {
            "description": "#654321", 
            "tempo": 85,
            "key": "Bb",
            "scale_mode": "minor",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["Bb", "C", "Db", "Eb", "F", "Gb", "Ab", "Bb"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["Bbm", "Ebm", "F", "Bbm"]
        },
        "B-b": {
            "description": "#C0C0C0", 
            "tempo": 85,
            "key": "B",
            "scale_mode": "major",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["B", "C#", "D#", "E", "F#", "G#", "A#", "B"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["B", "E", "F#", "B"]
        },
        "b-s": {
            "description": "#696969",  
            "tempo": 85,
            "key": "B",
            "scale_mode": "minor",
            "base_instrument": "Acoustic Grand Piano",
            "scale": ["B", "C#", "D", "E", "F#", "G", "A", "B"],
            "rhythm_pattern": [1, 1, 1, 1],
            "chord_progression": ["Bm", "Em", "F#", "Bm"]
        }
        };
    
    /******************************************
     * 常用工具函数
     ******************************************/

    function componentToHex(c) {
      let hex = c.toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    }
    function rgbToHex(r, g, b) {
      return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
    }
    function hexToRgb(hex) {
      if (typeof hex === 'object' && hex.hex) {
        hex = hex.hex;
      }
      if (typeof hex !== 'string') {
        // 尝试转换为字符串，或者直接抛出错误
        console.error("Expected a string for hex, but got:", hex);
        hex = String(hex); // 或者：throw new Error("hexToRgb expects a string");
      }
      hex = hex.replace(/^#/, '');
      if (hex.length === 3) {
        hex = hex.split('').map(c => c + c).join('');
      }
      let bigint = parseInt(hex, 16);
      let r = (bigint >> 16) & 255;
      let g = (bigint >> 8) & 255;
      let b = bigint & 255;
      return [r, g, b];
    }
    // 返回 [h, s, v]，h:0~360, s,v:0~100
    function rgbToHsv(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      let max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, v = max;
      let d = max - min;
      s = max === 0 ? 0 : d / max;
      if(max === min) {
        h = 0;
      } else {
        if(max === r) {
          h = (g - b) / d + (g < b ? 6 : 0);
        } else if(max === g) {
          h = (b - r) / d + 2;
        } else {
          h = (r - g) / d + 4;
        }
        h /= 6;
      }
      return [h * 360, s * 100, v * 100];
    }
    function computeAverageColor(imageData) {
      const data = imageData.data;
      let r = 0, g = 0, b = 0;
      const numPixels = data.length / 4;
      for(let i = 0; i < data.length; i += 4) {
        r += data[i];
        g += data[i+1];
        b += data[i+2];
      }
      r = Math.round(r / numPixels);
      g = Math.round(g / numPixels);
      b = Math.round(b / numPixels);
      return { r, g, b, hex: rgbToHex(r, g, b).toLowerCase() };
    }
    function computeComplexity(imageData) {
      const data = imageData.data;
      const numPixels = data.length / 4;
      let brightnessValues = [];
      for(let i = 0; i < data.length; i += 4) {
        let brightness = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
        brightnessValues.push(brightness);
      }
      const mean = brightnessValues.reduce((a, b) => a + b, 0) / brightnessValues.length;
      let variance = brightnessValues.reduce((sum, val) => sum + (val - mean) ** 2, 0) / brightnessValues.length;
      return Math.sqrt(variance);
    }
    function normalizeComplexityScores(scores) {
      const min = Math.min(...scores);
      const max = Math.max(...scores);
      if(min === max) return scores.map(() => 0);
      return scores.map(s => ((s - min) / (max - min)) * 2 - 1);
    }
    function distance(c1, c2) {
      return Math.sqrt((c1[0]-c2[0])**2 + (c1[1]-c2[1])**2 + (c1[2]-c2[2])**2);
    }
    
    // 辅助函数：将 note.pitch 中的 "-" 替换为 "b"
    function convertNoteName(noteName) {
        // 假定 noteName 中的 "-" 表示 flat，将其替换为 "b"
        return noteName.replace(/-/g, "b");
    }

    function roundDurationToAllowed(duration) {
      const unit = 0.125;
      return Math.round(duration / unit) * unit;
    }

    function generateNoteString(notes) {
      let tokens = [];
      for (let i = 0; i < notes.length; i++) {
        let note = notes[i];
        let { vfDuration, dots } = convertBeatToVF(note.duration);
        let dotStr = "";
        for (let j = 0; j < dots; j++) {
          dotStr += ".";
        }
        // 休止符直接用 "r"；非休止符添加默认八度标识 "/4"
        let noteToken = (note.pitch === "r")
          ? ("r" + vfDuration + dotStr)
          : (convertNoteName(note.pitch).toLowerCase() + vfDuration + dotStr);
        tokens.push(noteToken);
      }
      return tokens.join(" ");
    }

    function noteToVFString(note) {
      const { vfDuration, dots } = convertBeatToVF(note.duration);
      let dotStr = "";
      for (let i = 0; i < dots; i++) {
        dotStr += ".";
      }
      // 如果是休止符则返回 "r" 开头的字符串
      if (note.pitch === "r") {
        return "r" + vfDuration + dotStr;
      } else {
        // 使用 convertNoteName 确保音符名称格式正确（例如 "Bb" 会转为 "bb"）
        // 并默认加上八度标识 "/4"（你可以根据需要修改八度）
        return convertNoteName(note.pitch).toLowerCase() + vfDuration + dotStr;
      }
    }


    /**
     * 校验 note string 中所有 token 的拍值之和是否达到期望拍数（默认为 4 拍）。
     * 注：假设 token 格式类似 "c#/4q", "r8.", "f#/4h" 等，
     * 其中字母部分为音高（或休止符 r），"/4" 为八度（可选），后面为时值符号（w, h, q, 8, 16, 32）以及可能的附点。
     */
    function validateNoteString(noteString, expectedBeats = 4) {
      // 用空格或逗号分隔 token
      let tokens = noteString.split(/[\s,]+/).filter(token => token !== '');
      let totalBeats = 0;

      tokens.forEach(token => {
        // 匹配时值部分：寻找 w/h/q/8/16/32（可能带有尾部 "r" 用于休止符），以及附点部分
        let match = token.match(/(w|h|q|8|16|32)(r?)(\.*)$/);
        if (!match) {
          console.warn("validateNoteString: 无法解析 token:", token);
          return;
        }
        let symbol = match[1];
        let isRest = (match[2] === "r");
        let dots = match[3];
        let baseBeats = 0;
        switch(symbol) {
          case "w": baseBeats = 4; break;
          case "h": baseBeats = 2; break;
          case "q": baseBeats = 1; break;
          case "8": baseBeats = 0.5; break;
          case "16": baseBeats = 0.25; break;
          case "32": baseBeats = 0.125; break;
          default: break;
        }
        // 附点规则：每个附点增加前一个时值的一半
        let extra = 0;
        let prev = baseBeats;
        for (let i = 0; i < dots.length; i++) {
          let add = prev / 2;
          extra += add;
          prev = add;
        }
        totalBeats += baseBeats + extra;
      });

      if (Math.abs(totalBeats - expectedBeats) > 1e-6) {
        console.error(`validateNoteString: note string 总拍值为 ${totalBeats}（期望 ${expectedBeats}），noteString: ${noteString}`);
      } else {
        console.log(`validateNoteString: note string 拍值正确，总拍值为 ${totalBeats}`);
      }
      return totalBeats;
    }


    /******************************************
     * KMeans 聚类提取主导颜色（返回对象数组，每个对象 {hex, count}）
     ******************************************/
    function extractDominantColors(imageData, numColors = 4) {
      const data = imageData.data;
      let pixels = [];
      for (let i = 0; i < data.length; i += 4) {
        pixels.push([data[i], data[i + 1], data[i + 2]]);
      }
      let centroids = [];
      for (let i = 0; i < numColors; i++) {
        centroids.push(pixels[Math.floor(Math.random() * pixels.length)]);
      }
      let assignments = new Array(pixels.length).fill(0);
      const iterations = 10;
      // 将 counts 声明在循环外部，这样后续使用时可以访问到
      let counts = Array(numColors).fill(0);
      for (let iter = 0; iter < iterations; iter++) {
        for (let i = 0; i < pixels.length; i++) {
          let minDist = Infinity;
          let bestCluster = 0;
          for (let j = 0; j < numColors; j++) {
            let d = distance(pixels[i], centroids[j]);
            if (d < minDist) {
              minDist = d;
              bestCluster = j;
            }
          }
          assignments[i] = bestCluster;
        }
        let sums = Array(numColors).fill(null).map(() => [0, 0, 0]);
        counts = Array(numColors).fill(0);
        for (let i = 0; i < pixels.length; i++) {
          let cluster = assignments[i];
          sums[cluster][0] += pixels[i][0];
          sums[cluster][1] += pixels[i][1];
          sums[cluster][2] += pixels[i][2];
          counts[cluster]++;
        }
        for (let j = 0; j < numColors; j++) {
          if (counts[j] > 0) {
            centroids[j] = [
              Math.round(sums[j][0] / counts[j]),
              Math.round(sums[j][1] / counts[j]),
              Math.round(sums[j][2] / counts[j])
            ];
          }
        }
      }
      let dominantColors = [];
      for (let j = 0; j < numColors; j++) {
        if (counts[j] > 0) {
          dominantColors.push({
            hex: rgbToHex(centroids[j][0], centroids[j][1], centroids[j][2]).toLowerCase(),
            count: counts[j]
          });
        }
      }
      return dominantColors;
    }
    
    /******************************************
     * 为单个 grid（25×25）生成音符序列
     * 每个 grid 内总拍数为 1 拍
     ******************************************/
    // 动态生成节奏模式：输入当前 cell 的图像数据，输出一个数组，数组中每个数值表示该音符的时值，所有数值之和为 1。
    function generateRhythmPattern(cellData) {
        // 根据 cellData 计算复杂度（这里使用 computeComplexity 函数，假设数值大致在 0 ~ 100 范围内）
        let complexity = computeComplexity(cellData);
        // 将复杂度归一化到 [0, 1]（这里简单认为 100 为上限，可根据实际情况调整）
        let x = Math.min(Math.max(complexity / 100, 0), 1);
        // 定义 alpha 参数：x 越大，alpha 越大，倾向于选择更小的时值
        let alpha = 1 + 3 * x;
        
        // 允许的音符时值（可按需要扩展）
        const allowedDurations = [1, 0.5, 0.25, 0.125];
        let pattern = [];
        let remaining = 1;
        
        // 随机填充时值直到凑满 1 拍
        while (remaining > 0.0001) {
            // 筛选出不超过剩余时值的选项
            let possible = allowedDurations.filter(d => d <= remaining + 0.0001);
            if (possible.length === 0) break;
            // 计算各个可能时值的权重：权重 = (1/d)^(alpha)
            let weights = possible.map(d => Math.pow(1 / d, alpha));
            let sumWeights = weights.reduce((a, b) => a + b, 0);
            let r = Math.random() * sumWeights;
            let chosen = possible[0];
            for (let i = 0; i < possible.length; i++) {
            r -= weights[i];
            if (r <= 0) {
                chosen = possible[i];
                break;
            }
            }
            pattern.push(chosen);
            remaining -= chosen;
        }
        // 如果最后总和有微小误差，则调整最后一个音符
        let total = pattern.reduce((a, b) => a + b, 0);
        if (Math.abs(total - 1) > 0.0001) {
            pattern[pattern.length - 1] += (1 - total);
        }
        return pattern;
    }

    function selectNotesForGrid(cellData, baseScale) {
      // 计算该 cell 的平均颜色
      const avgColor = computeAverageColor(cellData);
      const avgHSV = rgbToHsv(avgColor.r, avgColor.g, avgColor.b);
      console.log("avgHSV:", avgHSV);
        
      
      // 利用 KMeans 提取 2 个主导颜色，假设返回的格式为：
      // [ { hex: "#RRGGBB", proportion: 0.6 }, { hex: "#RRGGBB", proportion: 0.4 } ]
      const dominantColors = extractDominantColors(cellData, 3);
      let totalCount = dominantColors.reduce((sum, obj) => sum + obj.count, 0);
      
      let dominantNotes = [];
      
      dominantColors.forEach(colorObj => {
        // 将 HEX 转为 RGB，再转为 HSV
        let rgb = hexToRgb(colorObj.hex);
        let domHSV = rgbToHsv(rgb[0], rgb[1], rgb[2]);
        console.log("domHSV:", domHSV);
        
        // 根据平均颜色计算色差（使用 HSV 中的 hue 和 saturation）
        let hue_diff = domHSV[0] - avgHSV[0];

        let sat_diff = domHSV[1] - avgHSV[1];
        let diff = hue_diff * 1.0 + sat_diff * 0.5;
        //　console.log("hue_diff:", domHSV[0], avgHSV[0], hue_diff, "sat_diff:", domHSV[1], sat_diff);
        
        // 根据一个比例因子计算偏移量
        let factor = 30.0;
        let offset = Math.round(diff / factor);
        
        // 以 baseScale 的中间音作为基础，然后加上偏移量
        let base_index = Math.floor(baseScale.length / 2);
        let note_index = base_index + offset;
        note_index = Math.max(0, Math.min(note_index, baseScale.length - 1));
        let pitch = baseScale[note_index];

        let proportion = colorObj.count / totalCount;
        let duration = proportion;
        if (duration >= 0.125){
          dominantNotes.push({ pitch: pitch, duration: duration });
        }
          
      });
      
      console.log("Grid notes:", dominantNotes);
      dominantNotes = adjustLeftHandChords(dominantNotes, 1);
      return dominantNotes;
    }


    // 将一个时值拆分为合法的 LilyPond 时值列表
    function splitDuration(duration) {
        const allowed = [4.0, 2.0, 1.0, 0.5, 0.25, 0.125];
        let result = [];
        let rem = duration;
        const tol = 1e-9;
        for (let d of allowed) {
            while (rem >= d - tol) {
            result.push(d);
            rem -= d;
            }
        }
        if (Math.abs(rem) > tol) {
            throw new Error(`无法精确拆分时值：${duration}，剩余：${rem}`);
        }
        return result;
    }

    // 检查音符的时值是否为允许的值（考虑浮点数容差），如果不在，则拆分为多个合法时值
    function expandNotes(notes) {
        const allowed = [4.0, 2.0, 1.0, 0.5, 0.25, 0.125];
        const tol = 1e-9;
        let expanded = [];
        notes.forEach(note => {
            // 对于休止符或其他特殊标记直接保留
            if (note.pitch === "r") {
            expanded.push(note);
            return;
            }
            // 判断当前音符的时值是否接近某个允许值
            let isAllowed = allowed.some(d => Math.abs(note.duration - d) < tol);
            if (isAllowed) {
                expanded.push(note);
            } else {
                // 拆分该时值
                let splits = splitDuration(note.duration);
                splits.forEach(d => {
                    expanded.push({ pitch: note.pitch, duration: d });
                });
            }
        });
        return expanded;
    }
    
    /******************************************
     * 合并相邻相同音阶的音符
     ******************************************/

    // Fisher-Yates 洗牌算法：对数组进行原地随机排序
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }    
    
    function mergeNotes(notesArray) {
        // 用一个对象来保存每个音高的总时值以及第一次出现的索引
        let pitchMap = {};
        notesArray.forEach((note, idx) => {
          if (pitchMap.hasOwnProperty(note.pitch)) {
            pitchMap[note.pitch].duration += note.duration;
          } else {
            pitchMap[note.pitch] = { duration: note.duration, firstIndex: idx };
          }
        });
        // 将对象转换为数组，每个元素为 { pitch, duration, firstIndex }
        let merged = Object.keys(pitchMap).map(pitch => {
          return {
            pitch: pitch,
            duration: pitchMap[pitch].duration,
            firstIndex: pitchMap[pitch].firstIndex
          };
        });
        // 按第一次出现的顺序排序
        merged.sort((a, b) => a.firstIndex - b.firstIndex);
        // shuffleArray(merged);
        // 移除 firstIndex 属性后返回结果
        merged.forEach(note => delete note.firstIndex);
        return merged;
      }

    // 新的合并函数：全局合并所有相同音符（不要求连续）
    function mergeAllNotes(notesArray) {
      let mergedMap = {};
      notesArray.forEach(note => {
        // 注意：如果 note.pitch 是休止符 "r"，可以单独处理，不进行合并
        if (note.pitch === "r") {
          // 使用特殊键区分休止符，例如 "r" + index 或直接保留每个休止符
          // 这里简单地直接添加（不合并休止符）
          if (!mergedMap["r"]) mergedMap["r"] = [];
          mergedMap["r"].push(note.duration);
        } else {
          if (mergedMap.hasOwnProperty(note.pitch)) {
            mergedMap[note.pitch] += note.duration;
          } else {
            mergedMap[note.pitch] = note.duration;
          }
        }
      });
      let merged = [];
      // 对非休止符部分
      for (let pitch in mergedMap) {
        if (pitch === "r") {
          // 对休止符，可以将它们逐个添加（或者根据需求合并休止符的时值）
          mergedMap["r"].forEach(dur => merged.push({ pitch: "r", duration: dur }));
        } else {
          merged.push({ pitch: pitch, duration: mergedMap[pitch] });
        }
      }
      return merged;
    }

    // 归一化：确保音符数组总和为 totalBeats（例如 4 拍）
    function normalizeNotesTotal(notes, totalBeats = 4) {
      let sum = notes.reduce((acc, note) => acc + note.duration, 0);
      if (Math.abs(sum - totalBeats) > 1e-6) {
        let factor = totalBeats / sum;
        return notes.map(note => ({
          pitch: note.pitch,
          duration: Math.round(note.duration * factor * 1000) / 1000
        }));
      }
      return notes;
    }

    function combineConsecutiveNotes(notes) {
      if (notes.length === 0) return [];
      let combined = [];
      let current = { pitch: notes[0].pitch, duration: notes[0].duration };
      for (let i = 1; i < notes.length; i++) {
        if (notes[i].pitch === current.pitch) {
          // 如果连续的音符 pitch 相同，则将时值相加
          current.duration += notes[i].duration;
        } else {
          combined.push(current);
          current = { pitch: notes[i].pitch, duration: notes[i].duration };
        }
      }
      combined.push(current);
      return combined;
    }
    
    /******************************************
     * 将拍数转换为 VexFlow 时值及附点信息
     * 假设 1 拍 = 四分音符 (4)
     ******************************************/
    function convertBeatToVF(duration) {
        const tol = 1e-9;
        // allowed durations及其对应的VexFlow记谱代码：
        // 4.0 -> whole note ("w")     → 4拍, tick = 16384
        // 2.0 -> half note ("2")       → 2拍, tick = 8192
        // 1.0 -> quarter note ("4")    → 1拍, tick = 4096
        // 0.5 -> eighth note ("8")     → 0.5拍, tick = 2048
        // 0.25 -> sixteenth note ("16")→ 0.25拍, tick = 1024
        // 0.125 -> thirty-second note ("32") → 0.125拍, tick = 512
        // 0.0625 -> sixty-fourth note ("64") → 0.0625拍, tick = 256
        if (Math.abs(duration - 4.0) < tol) return { vfDuration: "w", dots: 0 };
        if (Math.abs(duration - 2.0) < tol) return { vfDuration: "h", dots: 0 };
        if (Math.abs(duration - 1.0) < tol) return { vfDuration: "q", dots: 0 };
        if (Math.abs(duration - 0.5) < tol) return { vfDuration: "8", dots: 0 };
        if (Math.abs(duration - 0.25) < tol) return { vfDuration: "16", dots: 0 };
        if (Math.abs(duration - 0.125) < tol) return { vfDuration: "32", dots: 0 };
        // if (Math.abs(duration - 0.0625) < tol) return { vfDuration: "64", dots: 0 };
        // 如果遇到其他值，尝试先进行拆分，或者默认返回四分音符（这里可根据需要调整）
        console.warn("convertBeatToVF: 未知时值", duration, "，默认转换为四分音符");
        return { vfDuration: "q", dots: 0 };
    }

    // Acoustic Grand Piano 采样器，使用 Tone.js 官方示例的 Salamander 采样集
    const acousticSampler = new Tone.Sampler({
      urls: {
        "A0": "A0.mp3",
        "C1": "C1.mp3",
        "D#1": "Ds1.mp3",
        "F#1": "Fs1.mp3",
        "A1": "A1.mp3",
        "C2": "C2.mp3",
        "D#2": "Ds2.mp3",
        "F#2": "Fs2.mp3",
        "A2": "A2.mp3",
        "C3": "C3.mp3",
        "D#3": "Ds3.mp3",
        "F#3": "Fs3.mp3",
        "A3": "A3.mp3",
        "C4": "C4.mp3",
        "D#4": "Ds4.mp3",
        "F#4": "Fs4.mp3",
        "A4": "A4.mp3",
        "C5": "C5.mp3",
        "D#5": "Ds5.mp3",
        "F#5": "Fs5.mp3",
        "A5": "A5.mp3",
        "C6": "C6.mp3",
        "D#6": "Ds6.mp3",
        "F#6": "Fs6.mp3",
        "A6": "A6.mp3",
        "C7": "C7.mp3",
        "D#7": "Ds7.mp3",
        "F#7": "Fs7.mp3",
        "A7": "A7.mp3",
        "C8": "C8.mp3"
      },
      release: 1,
      baseUrl: "https://tonejs.github.io/audio/salamander/"
    }).toDestination();

    // Electric Piano 采样器
    // 注意：如果没有找到合适的采样文件，可以暂时采用 acousticSampler 替代，
    // 或根据你的需求加载其它公开的 Electric Piano 采样集。
    const electricSampler = new Tone.Sampler({
      urls: {
        "A0": "A0.mp3",
        "C1": "C1.mp3",
        "D#1": "Ds1.mp3",
        "F#1": "Fs1.mp3",
        "A1": "A1.mp3",
        "C2": "C2.mp3",
        "D#2": "Ds2.mp3",
        "F#2": "Fs2.mp3",
        "A2": "A2.mp3",
        "C3": "C3.mp3",
        "D#3": "Ds3.mp3",
        "F#3": "Fs3.mp3",
        "A3": "A3.mp3",
        "C4": "C4.mp3",
        "D#4": "Ds4.mp3",
        "F#4": "Fs4.mp3",
        "A4": "A4.mp3",
        "C5": "C5.mp3",
        "D#5": "Ds5.mp3",
        "F#5": "Fs5.mp3",
        "A5": "A5.mp3",
        "C6": "C6.mp3",
        "D#6": "Ds6.mp3",
        "F#6": "Fs6.mp3",
        "A6": "A6.mp3",
        "C7": "C7.mp3",
        "D#7": "Ds7.mp3",
        "F#7": "Fs7.mp3",
        "A7": "A7.mp3",
        "C8": "C8.mp3"
      },
      release: 1,
      // 假设 Electric Piano 采样文件存放在如下 URL（请根据实际情况调整）
      baseUrl: "https://example.com/electric-piano-samples/"
    }).toDestination();

    // 2. 播放函数：使用 Tone.js Sampler 播放扩展后的音符序列
    // ---------------------------
    async function playNotesWithSampler(rightNotes, leftNotes, toneParams, tempo) {
      // 选择采样器，假设已有 acousticSampler / electricSampler
      let sampler;
      if (toneParams.base_instrument === "Acoustic Grand Piano") {
        sampler = acousticSampler;
      } else if (toneParams.base_instrument === "Electric Piano") {
        sampler = electricSampler;
      } else {
        sampler = acousticSampler;
      }
      
      // 确保 AudioContext 已经启动
      if (Tone.context.state !== "running") {
        await Tone.start();
        console.log("AudioContext is now started");
      }
      
      // 对左右手部分分别调用 combineConsecutiveNotes 得到简化后的节拍数据
      let combinedRight = combineConsecutiveNotes(rightNotes);
      let combinedLeft  = combineConsecutiveNotes(leftNotes);

      // 获取当前时间
      let now = Tone.now();

      // 为左右手分别设置调度起始时间
      let rightTime = now;
      let leftTime  = now;

      const beatSec = 60 / tempo;

      // 播放右手部分
      combinedRight.forEach(note => {
        let noteDurationSec = note.duration * beatSec;
        if (note.pitch === "r") {
          // 如果是休止符，则推进时间
          rightTime += noteDurationSec;
        } else {
          let noteName = note.pitch.toUpperCase() + "4";
          sampler.triggerAttackRelease(noteName, noteDurationSec, rightTime, 1.0);
          rightTime += noteDurationSec;
        }
      });

      // 播放左手部分
      combinedLeft.forEach(note => {
        let noteDurationSec = note.duration * beatSec;
        if (note.pitch === "r") {
          leftTime += noteDurationSec;
        } else {
          let noteName = note.pitch.toUpperCase() + "3";
          sampler.triggerAttackRelease(noteName, noteDurationSec, leftTime, 0.5);
          leftTime += noteDurationSec;
        }
      });
    }



    
    /******************************************
     * 生成 LilyPond 代码文本（使用最终合并的音符序列）
     ******************************************/
    function generateLilyPondCode(rightNotes, leftNotes, toneParams, tempo) {
      // 生成右手和左手的记谱字符串
      let rightNoteStr = generateNoteString(rightNotes);
      let leftNoteStr = generateNoteString(leftNotes);

      // 调性标记（例如 "Cm"）
      const key = toneParams.key;
      const mode = toneParams.scale_mode;
      let keyLine = "\\key " + key + " \\" + mode;

      // 生成完整的 LilyPond 代码，使用双谱表结构（高音谱表和低音谱表）
      let code = `\\version "2.18.2"
        \score {
          <<
            \new Staff {
              \clef "treble"
              \tempo 4 = ${tempo}
              ${keyLine}
              { ${rightNoteStr} }
               \bar "|."
            }
            \new Staff \with { midiInstrumentVolume = #0.2 } {
            \clef "bass"
            { ${leftNoteStr} }
            \bar "|."
          }
          >>
          \layout { }
          \midi { }
        }`;
      return code;
    }

    /******************************************
     * 生成左手和弦部分
     * 从以点击处为中心的 100×100 区域中提取最多 8 个颜色，
     * 根据颜色占比分配总拍数（例如 4 拍）
     ******************************************/
    function generateLeftHandChords(regionData, baseScale, totalBeats = 4) {
      // 使用 KMeans 提取 8 个主要颜色（带 count 信息）
      let dominantObjs = extractDominantColors(regionData, 8);
      // 计算左手区域的平均颜色
      let avgColor = computeAverageColor(regionData);
      let avgHSV = rgbToHsv(avgColor.r, avgColor.g, avgColor.b);
      
      // 计算总像素计数（取 dominantObjs 的 count 之和）
      let totalCount = dominantObjs.reduce((sum, obj) => sum + obj.count, 0);
      
      let chordNotes = [];
      dominantObjs.forEach(obj => {
        let rgb = hexToRgb(obj.hex);
        let domHSV = rgbToHsv(rgb[0], rgb[1], rgb[2]);
        let hue_diff = domHSV[0] - avgHSV[0];
        let sat_diff = domHSV[1] - avgHSV[1];
        let diff = hue_diff * 0.8 + sat_diff * 0.3;
        let factor = 30.0;
        let offset = Math.round(diff / factor);
        let base_index = Math.floor(baseScale.length / 2);
        let note_index = base_index + offset;
        note_index = Math.max(0, Math.min(note_index, baseScale.length - 1));
        let pitch = baseScale[note_index];
        // 计算该颜色的占比
        let proportion = obj.count / totalCount;
        let duration = proportion * totalBeats;
        if (duration >= 0.25){
          chordNotes.push({ pitch: pitch, duration: duration });
        }
      });
      console.log(chordNotes)
      // 合并相邻相同音符的时值
      //　chordNotes = mergeNotes(chordNotes);
      console.log(chordNotes)
      // 调整左手和弦部分的时值，使每个时值都是 0.125 的倍数，且总拍数为 totalBeats
      chordNotes = adjustLeftHandChords(chordNotes, totalBeats);
      return chordNotes;
    }

    function adjustLeftHandChords(chords, totalBeats = 4) {
      // 先四舍五入每个音符的时值
      let adjusted = chords.map(chord => ({
        pitch: chord.pitch,
        duration: roundDurationToAllowed(chord.duration)
      }));
      
      let sum = adjusted.reduce((acc, chord) => acc + chord.duration, 0);
      let diff = totalBeats - sum;
      
      // 如果误差超过一个单位（0.125），进行调整
      if (Math.abs(diff) >= 0.125) {
        // 找出时值最大的音符的索引
        let idx = adjusted.reduce((maxIdx, chord, i, arr) => 
          chord.duration > arr[maxIdx].duration ? i : maxIdx, 0);
        // 调整该音符的时值，并重新四舍五入
        adjusted[idx].duration = roundDurationToAllowed(adjusted[idx].duration + diff);
      }
      return adjusted;
    }

    function adjustLeftHandChords_new(chords, totalBeats = 4) {
      const unit = 0.125;
      // 1. 对每个和弦先四舍五入，并过滤掉时值 < 0.25 的和弦
      let adjusted = chords
        .map(chord => ({
          pitch: chord.pitch,
          duration: roundDurationToAllowed(chord.duration)
        }))
        .filter(chord => chord.duration >= 0.25);
      
      // 2. 计算剩余和弦的总时值
      let sum = adjusted.reduce((acc, chord) => acc + chord.duration, 0);
      let diff = totalBeats - sum;
      
      // 3. 如果缺失的时值至少为一个单位，则均摊 diff 到每个和弦上
      if (Math.abs(diff) >= unit && adjusted.length > 0) {
        let extra = diff / adjusted.length;
        adjusted = adjusted.map(chord => ({
          pitch: chord.pitch,
          duration: roundDurationToAllowed(chord.duration + extra)
        }));
      }
      
      return adjusted;
    }

    
    /******************************************
     * 利用 VexFlow 渲染五线谱（使用最终合并的音符序列）
     ******************************************/
    function renderGrandStaff(expandedNotes, toneParams, tempo) {
        document.getElementById("lilypondContainer").innerHTML = "";
        const VF = Vex.Flow;
        const div = document.getElementById("lilypondContainer");
        const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
        renderer.resize(800, 400);
        const context = renderer.getContext();
        
        // 使用转换函数设置调号
        const keySignature = toneParams.key + (toneParams.scale_mode === "minor" ? "m" : "");
        console.log("Key signature:", keySignature);

        const stave = new VF.Stave(10, 40, 750);
        stave.addClef("treble")
            .addTimeSignature("4/4")
            //.addKeySignature(keySignature);
        stave.setText(keySignature, Vex.Flow.Modifier.Position.LEFT);
        context.save();
        stave.setContext(context).draw();
        context.restore();
        context.setTransform(1, 0, 0, 1, 0, 0);
        
        let vfNotes = [];
        // 根据扩展后的音符生成 VexFlow 的 StaveNote 对象
        expandedNotes.forEach(note => {
            let { vfDuration, dots } = convertBeatToVF(note.duration);
            let staveNote;
            if (note.pitch === "r") {
                // 休止符使用特殊记号：这里用 "b/4" 作占位键值，再在 duration 后加上 "r"
                staveNote = new VF.StaveNote({ keys: ["b/4"], duration: vfDuration + "r" });
            } else {
                // 非休止符则生成对应音高的音符，假定 octave 为 4
                let converted = convertNoteName(note.pitch);
                let keyStr = convertNoteName(note.pitch).toLowerCase() + "/4";
                console.log("Note pitch:", note.pitch, "->", keyStr);
                staveNote = new VF.StaveNote({ keys: [keyStr], duration: vfDuration });
                
                // 如果音符名称中含有 "b" 或 "#"，说明该音符不是自然音，应在左侧显示附加记号
                if (converted.includes("b") || converted.includes("#")) {
                    // 如果含有 "b"，则附加 flat；如果含有 "#"，则附加 sharp
                    let accidentalSymbol = converted.includes("b") ? "b" : "#";
                    staveNote.addAccidental(0, new VF.Accidental(accidentalSymbol));
                }
            }
            for (let i = 0; i < dots; i++) {
                staveNote.addDotToAll();
            }
            vfNotes.push(staveNote);
        });
        

        const voice = new VF.Voice({ num_beats: 4, beat_value: 4 });
        voice.addTickables(vfNotes);
        new VF.Formatter().joinVoices([voice]).format([voice], 700);
        voice.draw(context, stave);

        // 自动为连续相同音高的音符添加连音符（Tie）
        let ties = [];
        for (let i = 1; i < vfNotes.length; i++) {
            // 仅对非休止符进行判断，休止符通常不需要连音
            // 这里比较两个音符的键值字符串，如果相同，则认为音高相同
            let prevKey = vfNotes[i - 1].getKeys()[0];
            let curKey = vfNotes[i].getKeys()[0];
            // 排除休止符的占位键值 "b/4"（假设休止符都用该键值构造）
            if (prevKey !== "b/4" && curKey !== "b/4" && prevKey === curKey) {
                let tie = new VF.StaveTie({
                    first_note: vfNotes[i - 1],
                    last_note: vfNotes[i]
                });
                ties.push(tie);
            }
        }
        // 绘制所有 tie 对象
        ties.forEach(tie => tie.setContext(context).draw());
    }

    function renderLeftHand(leftExpandedNotes, toneParams, tempo) {
      // 获取容器（假设与右手共用同一个容器）
      const container = document.getElementById("lilypondContainer");
      // 如果需要合并双谱表，可不清空容器；否则根据实际情况处理
      // container.innerHTML = "";

      const VF = Vex.Flow;
      // 创建渲染器（如果右手已经创建过，可以复用同一个 Renderer）
      const renderer = new VF.Renderer(container, VF.Renderer.Backends.SVG);
      // 假设整体宽度和高度与右手一致，也可以根据需要调整
      renderer.resize(800, 400);
      const context = renderer.getContext();
      
      // 创建低音谱表：设置在页面下方（例如 y 坐标为 200 或 250）
      const bassStave = new VF.Stave(10, 250, 750);
      bassStave
        .addClef("bass")
        .addTimeSignature("4/4")
        // 如果需要设置调号，可取消下面注释，并确保 toneParams.key 格式正确
        // .addKeySignature(toneParams.key + (toneParams.scale_mode === "minor" ? "m" : ""))
        ;
      context.save();
      bassStave.setContext(context).draw();
      context.restore();

      // 生成 VF.StaveNote 数组：遍历 leftExpandedNotes 数组
      let vfNotes = [];
      leftExpandedNotes.forEach(note => {
        // 调用你已有的转换函数，将数字时值转换为 VexFlow 所需的时值字符串及附点数量
        let { vfDuration, dots } = convertBeatToVF(note.duration);
        let staveNote;
        if (note.pitch === "r") {
          // 休止符：低音谱表中，使用一个占位键值（例如 "b/3"）并在时值后附加 "r"
          staveNote = new VF.StaveNote({ keys: ["b/3"], duration: vfDuration + "r" });
        } else {
          // 非休止符：调用转换函数（如 convertNoteName）得到音符名称，
          // 这里默认使用 3 作为低音谱表的八度编号
          let converted = convertNoteName(note.pitch);
          let keyStr = converted.toLowerCase() + "/3";
          console.log("Left-hand Note pitch:", note.pitch, "->", keyStr);
          staveNote = new VF.StaveNote({ keys: [keyStr], duration: vfDuration });
          // 如果音符包含升降号，则添加相应的 accidental
          if (converted.includes("b") || converted.includes("#")) {
            let accidentalSymbol = converted.includes("b") ? "b" : "#";
            staveNote.addAccidental(0, new VF.Accidental(accidentalSymbol));
          }
        }
        // 如果有附点，则添加对应数量的附点
        for (let i = 0; i < dots; i++) {
          staveNote.addDotToAll();
        }
        vfNotes.push(staveNote);
      });

      // 创建 Voice 对象，指定 4/4 节拍
      const voice = new VF.Voice({ num_beats: 4, beat_value: 4 });
      voice.addTickables(vfNotes);

      // 利用 Formatter 对 Voice 进行排版与格式化，设置音符间距（例如 700 像素）
      new VF.Formatter().joinVoices([voice]).format([voice], 700);

      // 绘制左手音符到 bassStave 上
      voice.draw(context, bassStave);

      // 如需要自动添加连线（tie），可以按照右手代码的方式处理：
      let ties = [];
      for (let i = 1; i < vfNotes.length; i++) {
        let prevKey = vfNotes[i - 1].getKeys()[0];
        let curKey = vfNotes[i].getKeys()[0];
        // 排除休止符占位键值 "b/3"（假设所有休止符都用此键值构造）
        if (prevKey !== "b/3" && curKey !== "b/3" && prevKey === curKey) {
          let tie = new VF.StaveTie({
            first_note: vfNotes[i - 1],
            last_note: vfNotes[i]
          });
          ties.push(tie);
        }
      }
      ties.forEach(tie => tie.setContext(context).draw());
    }
    

    function renderGrandStaff(expandedRightNotes, expandedLeftNotes, toneParams, tempo) {
      // 清空容器并初始化渲染器
      const container = document.getElementById("lilypondContainer");
      container.innerHTML = "";
      const VF = Vex.Flow;
      const renderer = new VF.Renderer(container, VF.Renderer.Backends.SVG);
      renderer.resize(800, 400);
      const context = renderer.getContext();
      
      // 设置调号（可根据需要调整）
      const keySignature = toneParams.key + (toneParams.scale_mode === "minor" ? "m" : "");
      console.log("Key signature:", keySignature);
      
      // ---------------------------
      // 绘制右手（高音）谱表
      // ---------------------------
      // 开启一组，确保右手谱表在独立的 <g> 中
      context.openGroup();
      
      const trebleStave = new VF.Stave(80, 40, 670);
      trebleStave
        .addClef("treble")
        .addTimeSignature("4/4");
        // 如需显示调号，也可以启用 .addKeySignature(keySignature)
      trebleStave.setText(keySignature, Vex.Flow.Modifier.Position.LEFT);
      trebleStave.setContext(context).draw();
      
      // 此处可以绘制右手的音符（使用直接 API 构造 VF.StaveNote 等）…
      // 例如：
      let trebleNotes = []; // 假设你已有右手 VF.StaveNote 数组
      expandedRightNotes.forEach(note => {
            let { vfDuration, dots } = convertBeatToVF(note.duration);
            let staveNote;
            if (note.pitch === "r") {
                // 休止符使用特殊记号：这里用 "b/4" 作占位键值，再在 duration 后加上 "r"
                staveNote = new VF.StaveNote({ keys: ["b/4"], duration: vfDuration + "r" });
            } else {
                // 非休止符则生成对应音高的音符，假定 octave 为 4
                let converted = convertNoteName(note.pitch);
                let keyStr = convertNoteName(note.pitch).toLowerCase() + "/4";
                console.log("Note pitch:", note.pitch, "->", keyStr);
                staveNote = new VF.StaveNote({ keys: [keyStr], duration: vfDuration });
                
                // 如果音符名称中含有 "b" 或 "#"，说明该音符不是自然音，应在左侧显示附加记号
                if (converted.includes("b") || converted.includes("#")) {
                    // 如果含有 "b"，则附加 flat；如果含有 "#"，则附加 sharp
                    let accidentalSymbol = converted.includes("b") ? "b" : "#";
                    staveNote.addAccidental(0, new VF.Accidental(accidentalSymbol));
                }
            }
            for (let i = 0; i < dots; i++) {
                staveNote.addDotToAll();
            }
            trebleNotes.push(staveNote);
        });
        

        const treblevoice = new VF.Voice({ num_beats: 4, beat_value: 4 });
        treblevoice.addTickables(trebleNotes);
        new VF.Formatter().joinVoices([treblevoice]).format([treblevoice], 600);
        treblevoice.draw(context, trebleStave);

        // 自动为连续相同音高的音符添加连音符（Tie）
        let ties = [];
        for (let i = 1; i < trebleNotes.length; i++) {
            // 仅对非休止符进行判断，休止符通常不需要连音
            // 这里比较两个音符的键值字符串，如果相同，则认为音高相同
            let prevKey = trebleNotes[i - 1].getKeys()[0];
            let curKey = trebleNotes[i].getKeys()[0];
            // 排除休止符的占位键值 "b/4"（假设休止符都用该键值构造）
            if (prevKey !== "b/4" && curKey !== "b/4" && prevKey === curKey) {
                let tie = new VF.StaveTie({
                    first_note: trebleNotes[i - 1],
                    last_note: trebleNotes[i]
                });
                ties.push(tie);
            }
        }
        // 绘制所有 tie 对象
        ties.forEach(tie => tie.setContext(context).draw());

      context.closeGroup(); // 结束右手谱表的组
      
      // ---------------------------
      // 绘制左手（低音）谱表
      // ---------------------------
      // 开启一个新组，确保左手谱表不继承前面的变换
      context.openGroup();
      
      // 这里我们将左手谱表放置在 (80, 150)
      const bassStave = new VF.Stave(80, 150, 670);
      bassStave
        .addClef("bass")
        .addTimeSignature("4/4")
        // .addKeySignature(keySignature);  // 如需显示调号
      bassStave.setText(keySignature, Vex.Flow.Modifier.Position.LEFT);
      bassStave.setContext(context).draw();
      
      // 绘制左手音符。假设 expandedLeftNotes 为已处理的左手数据，
      // 并且你使用类似的方式构造 VF.StaveNote 数组（注意低音谱表一般使用 octave 3 或更低）
      let bassNotes = [];
      expandedLeftNotes.forEach(note => {
        let { vfDuration, dots } = convertBeatToVF(note.duration);
        let staveNote;
        
        if (note.pitch === "r") {
          // 休止符：低音谱表中，用 "b/3" 作为占位键值
          console.log("Bass - 3");
          staveNote = new VF.StaveNote({ keys: ["b/3"], duration: vfDuration + "r" });
        } else {
          // 非休止符：假定 octave 为 3
          let converted = convertNoteName(note.pitch);
          let keyStr = converted.toLowerCase() + "/3";
          console.log("Left-hand Note pitch:", note.pitch, "->", keyStr);
          staveNote = new VF.StaveNote({ keys: [keyStr], duration: vfDuration });
          if (converted.includes("b") || converted.includes("#")) {
            let accidentalSymbol = converted.includes("b") ? "b" : "#";
            staveNote.addAccidental(0, new VF.Accidental(accidentalSymbol));
          }
        }
        staveNote.setStave(bassStave);
        for (let i = 0; i < dots; i++) {
          staveNote.addDotToAll();
        }
        bassNotes.push(staveNote);
      });
      
      const bassVoice = new VF.Voice({ num_beats: 4, beat_value: 4 });
      bassVoice.addTickables(bassNotes);
      new VF.Formatter().joinVoices([bassVoice]).format([bassVoice], 600);
      bassVoice.draw(context, bassStave);

      // 自动为连续相同音高的音符添加连音符（Tie）
      let bassties = [];
        for (let i = 1; i < bassNotes.length; i++) {
            // 仅对非休止符进行判断，休止符通常不需要连音
            // 这里比较两个音符的键值字符串，如果相同，则认为音高相同
            let prevKey = bassNotes[i - 1].getKeys()[0];
            let curKey = bassNotes[i].getKeys()[0];
            // 排除休止符的占位键值 "b/3"（假设休止符都用该键值构造）
            if (prevKey !== "b/3" && curKey !== "b/3" && prevKey === curKey) {
                let tie = new VF.StaveTie({
                    first_note: bassNotes[i - 1],
                    last_note: bassNotes[i]
                });
                bassties.push(tie);
            }
        }
        // 绘制所有 tie 对象
        bassties.forEach(tie => tie.setContext(context).draw());
      
      context.closeGroup(); // 结束左手谱表组
    }

    /******************************************
     * 用 Web Audio API 播放最终合并后的音符序列
     ******************************************/
    function playNotes(expandedNotes, tempo) {
        const beatDuration = 60 / tempo; // 每拍秒数
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        let currentTime = audioCtx.currentTime;
        
        expandedNotes.forEach(note => {
            // 对休止符不播放声音，但延迟相应时间
            if (note.pitch === "r") {
                currentTime += note.duration * beatDuration;
                return;
            }
            let frequency = getFrequency(note.pitch);
            let durationSeconds = note.duration * beatDuration;
            
            // 创建 oscillator 与 gainNode
            let oscillator = audioCtx.createOscillator();
            let gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.frequency.setValueAtTime(frequency, currentTime);
            oscillator.type = 'sine';  // 可尝试 "triangle", "sawtooth", 等其他类型
            
            // 设置包络：攻击和释放阶段
            let attackTime = 0.01;   // 10毫秒攻击
            let releaseTime = 0.01;  // 10毫秒释放
            gainNode.gain.setValueAtTime(0, currentTime);
            gainNode.gain.linearRampToValueAtTime(0.5, currentTime + attackTime);
            gainNode.gain.setValueAtTime(0.5, currentTime + durationSeconds - releaseTime);
            gainNode.gain.linearRampToValueAtTime(0, currentTime + durationSeconds);
            
            oscillator.start(currentTime);
            oscillator.stop(currentTime + durationSeconds);
            
            currentTime += durationSeconds;
        });
    }
    
    // 简单的音符到频率映射（假定 octave 4）
    function getFrequency(note) {
      const noteFrequencies = {
        "C": 261.63,
        "C#": 277.18,
        "D": 293.66,
        "D#": 311.13,
        "E": 329.63,
        "F": 349.23,
        "F#": 369.99,
        "G": 392.00,
        "G#": 415.30,
        "A": 440.00,
        "A#": 466.16,
        "B": 493.88
      };
      note = note.toUpperCase();
      return noteFrequencies[note] || 440.0;
    }
    

    // 将 RGB 转换为 Lab 色彩空间
    function rgbToLab(rgb) {
        // rgb: [r, g, b]，范围 0~255
        let [r, g, b] = rgb.map(v => v / 255);
        
        // sRGB to linear RGB
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
        
        // 转换到 XYZ（D65 标准光源）
        let X = r * 0.4124 + g * 0.3576 + b * 0.1805;
        let Y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        let Z = r * 0.0193 + g * 0.1192 + b * 0.9505;
        
        // 将 XYZ 按比例乘以 100
        X *= 100;
        Y *= 100;
        Z *= 100;
    
        // D65 参考白点
        const refX = 95.047, refY = 100.0, refZ = 108.883;
        let x = X / refX;
        let y = Y / refY;
        let z = Z / refZ;
        
        // XYZ 转 Lab 的 f(t) 函数
        x = x > 0.008856 ? Math.cbrt(x) : (7.787 * x + 16 / 116);
        y = y > 0.008856 ? Math.cbrt(y) : (7.787 * y + 16 / 116);
        z = z > 0.008856 ? Math.cbrt(z) : (7.787 * z + 16 / 116);
        
        const L = (116 * y) - 16;
        const a = 500 * (x - y);
        const b_val = 200 * (y - z);
        
        return [L, a, b_val];
    }

    // 将 HEX 转换为 Lab
    function hexToLab(hex) {
        const rgb = hexToRgb(hex);
        return rgbToLab(rgb);
    }

    // CIEDE2000 色差算法实现
    function deltaE2000(lab1, lab2) {
        // 参数设定
        const kL = 1, kC = 1, kH = 1;
        
        const [L1, a1, b1] = lab1;
        const [L2, a2, b2] = lab2;
        
        const avgL = (L1 + L2) / 2;
        
        const C1 = Math.sqrt(a1 * a1 + b1 * b1);
        const C2 = Math.sqrt(a2 * a2 + b2 * b2);
        const avgC = (C1 + C2) / 2;
        
        const G = 0.5 * (1 - Math.sqrt(Math.pow(avgC, 7) / (Math.pow(avgC, 7) + Math.pow(25, 7))));
        
        const a1Prime = (1 + G) * a1;
        const a2Prime = (1 + G) * a2;
    
        const C1Prime = Math.sqrt(a1Prime * a1Prime + b1 * b1);
        const C2Prime = Math.sqrt(a2Prime * a2Prime + b2 * b2);
        
        const avgCPrime = (C1Prime + C2Prime) / 2;
        
        let h1Prime = Math.atan2(b1, a1Prime);
        if (h1Prime < 0) h1Prime += 2 * Math.PI;
        let h2Prime = Math.atan2(b2, a2Prime);
        if (h2Prime < 0) h2Prime += 2 * Math.PI;
        
        let dhPrime;
        if (Math.abs(h1Prime - h2Prime) > Math.PI) {
            dhPrime = h2Prime - h1Prime - Math.sign(h2Prime - h1Prime) * 2 * Math.PI;
        } else {
            dhPrime = h2Prime - h1Prime;
        }
        
        const deltaHPrime = 2 * Math.sqrt(C1Prime * C2Prime) * Math.sin(dhPrime / 2);
        const deltaLPrime = L2 - L1;
        const deltaCPrime = C2Prime - C1Prime;
    
        let avgHPrime;
        if (Math.abs(h1Prime - h2Prime) > Math.PI) {
            avgHPrime = (h1Prime + h2Prime + 2 * Math.PI) / 2;
        } else {
            avgHPrime = (h1Prime + h2Prime) / 2;
        }
        
        const T = 1 -
            0.17 * Math.cos(avgHPrime - Math.PI / 6) +
            0.24 * Math.cos(2 * avgHPrime) +
            0.32 * Math.cos(3 * avgHPrime + Math.PI / 30) -
            0.20 * Math.cos(4 * avgHPrime - 21 * Math.PI / 60);
        
        const deltaTheta = (30 * Math.PI / 180) * Math.exp(-Math.pow((avgHPrime * 180 / Math.PI - 275) / 25, 2));
        
        const R_C = 2 * Math.sqrt(Math.pow(avgCPrime, 7) / (Math.pow(avgCPrime, 7) + Math.pow(25, 7)));
        
        const S_L = 1 + ((0.015 * Math.pow(avgL - 50, 2)) / Math.sqrt(20 + Math.pow(avgL - 50, 2)));
        const S_C = 1 + 0.045 * avgCPrime;
        const S_H = 1 + 0.015 * avgCPrime * T;
        
        const R_T = -Math.sin(2 * deltaTheta) * R_C;
        
        const deltaE = Math.sqrt(
            Math.pow(deltaLPrime / (kL * S_L), 2) +
            Math.pow(deltaCPrime / (kC * S_C), 2) +
            Math.pow(deltaHPrime / (kH * S_H), 2) +
            R_T * (deltaCPrime / (kC * S_C)) * (deltaHPrime / (kH * S_H))
        );
        
        return deltaE;
    }

    // 根据中心区域的 HEX 颜色，在 color_tone_dict 中寻找距离最近的颜色，返回对应的 tone 值（例如 "C-b"）
    function findClosestColor(base_hex, color_tone_dict) {
        const base_lab = hexToLab(base_hex);
        let best_color = null;
        let best_distance = Infinity;
        for (let hex_val in color_tone_dict) {
            const lab = hexToLab(hex_val);
            const d = deltaE2000(base_lab, lab);
            if (d < best_distance) {
            best_distance = d;
            best_color = hex_val;
            }
        }
        // 返回对应的 tone 值
        return color_tone_dict[best_color];
    }

    /******************************************
     * 主程序逻辑
     ******************************************/
    let clickCount = 0;
    let currentImage = new Image();
    const imageInput = document.getElementById("imageUpload");
    const canvas = document.getElementById("imageCanvas");
    const ctx = canvas.getContext("2d");
    const lilyCodePre = document.getElementById("lilypondCode");
    
    
    imageInput.addEventListener("change", function(event) {
      const file = event.target.files[0];
      if(!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        currentImage.onload = function() {
          // 根据设备尺寸调整画布：手机屏幕宽度-50px，电脑端固定1000px
          const screenWidth = window.innerWidth;
          let canvasWidth = 1000;
          if(screenWidth < 1100) canvasWidth = screenWidth - 50;
          const scale = canvasWidth / currentImage.width;
          canvas.width = canvasWidth;
          canvas.height = currentImage.height * scale;
          ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
          // 图片加载完成后显示 canvas 和 Clear 按钮
          canvas.style.display = "block";
          document.getElementById("clearButton").style.display = "inline-block";
        }
        currentImage.src = e.target.result;
      }
      reader.readAsDataURL(file);
    });
    
    canvas.addEventListener("click", function(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      processClickedRegion(x, y);
    });
    
    function processClickedRegion(x, y) {
        const regionSize = 50;
        const halfRegion = regionSize / 2;
        let regionX = Math.max(0, x - halfRegion);
        let regionY = Math.max(0, y - halfRegion);
        if(regionX + regionSize > canvas.width) regionX = canvas.width - regionSize;
        if(regionY + regionSize > canvas.height) regionY = canvas.height - regionSize;
        
        // 增加点击编号
        clickCount++;
        // 在原图上绘制边框（红色，线宽为 2）
        ctx.strokeStyle = "#D0104C";
        ctx.lineWidth = 2;
        ctx.strokeRect(regionX, regionY, regionSize, regionSize);


        const regionoutSize = 100;
        const halfRegionout = regionoutSize / 2;
        let regionoutX = Math.max(0, x - halfRegionout);
        let regionoutY = Math.max(0, y - halfRegionout);
        if(regionoutX + regionoutSize > canvas.width) regionoutX = canvas.width - regionoutSize;
        if(regionoutY + regionoutSize > canvas.height) regionoutY = canvas.height - regionoutSize;
        
        ctx.strokeStyle = "#81C7D4";
        ctx.lineWidth = 2;
        ctx.strokeRect(regionoutX, regionoutY, regionoutSize, regionoutSize);
        

        // 绘制编号文本，位置在边框右侧略偏上
        ctx.fillStyle = "#D0104C";
        ctx.font = "16px Arial";
        ctx.fillText(clickCount, regionX + regionSize + 5, regionY + 16);
        
        // 获取 50×50 区域图像数据
        const regionData = ctx.getImageData(regionX, regionY, regionSize, regionSize);
        const avgColor = computeAverageColor(regionData);
        console.log("区域平均颜色:", avgColor);
        
        // 根据平均颜色判断调性（未匹配则默认 "C-b"）
        // const toneKey = COLOR_TONE_DICT[avgColor.hex] || "C-b";
        const toneKey = findClosestColor(avgColor.hex, COLOR_TONE_DICT);
        const toneParams = COLOR_TO_TONE_MAP[toneKey];
        console.log("调性参数:", toneParams);
        
        // 将 50×50 区域拆分为 4 个 grid（2×2）
        const cellSize = 25;
        let allGridNotes = [];
        // 顺序：左上、右上、左下、右下
        for(let row = 0; row < 2; row++) {
            for(let col = 0; col < 2; col++) {
                let cellX = regionX + col * cellSize;
                let cellY = regionY + row * cellSize;
                let cellData = ctx.getImageData(cellX, cellY, cellSize, cellSize);
                let gridNotes = selectNotesForGrid(cellData, toneParams.scale);
                allGridNotes = allGridNotes.concat(gridNotes);
            }
        }
        console.log("所有grid音符（合并前）:", allGridNotes);
      
        // 合并相邻同音符
        let mergedNotes = mergeNotes(allGridNotes);
        console.log("合并后的音符序列:", mergedNotes);

        let totalBeats = mergedNotes.reduce((sum, note) => sum + note.duration, 0);
        if(totalBeats < 4) {
            let missing = 4 - totalBeats;
            mergedNotes.push({ pitch: "r", duration: missing });
            } else if(totalBeats > 4) {
            let diff = totalBeats - 4;
            mergedNotes[mergedNotes.length - 1].duration -= diff;
        }
        console.log("调整后的合并音符序列，总拍数应为4:", mergedNotes);

        // 调用 expandNotes 将合并后的音符序列拆分成合法的时值
        let finalRightNotes = expandNotes(allGridNotes);
        console.log("拆分后的右手音符序列:", finalRightNotes);

        // 生成左手部分：以点击处为中心的100×100区域
        const leftRegionSize = 100;
        const halfLeft = leftRegionSize / 2;
        let leftX = Math.max(0, x - halfLeft);
        let leftY = Math.max(0, y - halfLeft);
        if (leftX + leftRegionSize > canvas.width) leftX = canvas.width - leftRegionSize;
        if (leftY + leftRegionSize > canvas.height) leftY = canvas.height - leftRegionSize;
        const regionData100 = ctx.getImageData(leftX, leftY, leftRegionSize, leftRegionSize);
        let leftNotes = generateLeftHandChords(regionData100, toneParams.scale, 4);
        console.log("左手和弦部分:", leftNotes);
        // let mergedLeft = mergeNotes(leftNotes);
        let finalLeftChords = expandNotes(leftNotes);
        console.log("拆分后的左手和弦部分:", finalLeftChords);
      
        // 根据区域内复杂度调整 tempo（与原逻辑相同）
        let complexities = [];
        for(let row = 0; row < 2; row++) {
            for(let col = 0; col < 2; col++) {
            let cellData = ctx.getImageData(regionX + col * cellSize, regionY + row * cellSize, cellSize, cellSize);
            complexities.push(computeComplexity(cellData));
            }
        }
        let normalizedComplexities = normalizeComplexityScores(complexities);
        let avgNormalized = normalizedComplexities.reduce((a, b) => a + b, 0) / normalizedComplexities.length;
        let adjustedTempo = Math.round(toneParams.tempo + avgNormalized * 20);
        console.log("调整后的 tempo:", adjustedTempo);
      

        // 生成并显示 LilyPond 源代码
        // const lilyCode = generateLilyPondCode(expandedNotes, toneParams, adjustedTempo);
        const lilyCode = generateLilyPondCode(finalRightNotes, finalLeftChords, toneParams, adjustedTempo);
        lilyCodePre.textContent = lilyCode;
        // 渲染五线谱
        // renderNotation(expandedNotes, toneParams, adjustedTempo);
        // renderGrandStaff(finalRightNotes, toneParams, adjustedTempo);
        // renderLeftHand(finalLeftChords, toneParams, adjustedTempo)
        renderGrandStaff(finalRightNotes, finalLeftChords, toneParams, adjustedTempo)
        
        // 播放声音
        // playNotesWithSampler(expandedNotes, toneParams, adjustedTempo);
        playNotesWithSampler(finalRightNotes, finalLeftChords, toneParams, adjustedTempo);

    }

    // “Clear” 按钮事件：清除画布并重绘原图，同时重置编号
    document.getElementById("clearButton").addEventListener("click", function() {
        if (!currentImage.src) return;
        // 清除整个画布
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // 重绘原始图片
        ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
        // 重置点击编号
        clickCount = 0;
    });

    
  </script>

</body>
</html>