<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markové“¾å’Œå¼¦ç”Ÿæˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vexflow/1.2.93/vexflow-min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        #notation {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }
        svg {
            margin: 10px;
        }
        button {
            padding: 10px;
            margin: 10px;
            font-size: 16px;
        }
    </style>
</head>
<body>

<h2>Markové“¾å’Œå¼¦åºåˆ— (äº”çº¿è°± & éŸ³é¢‘æ’­æ”¾)</h2>
<button onclick="playMusic()">ğŸµ æ’­æ”¾éŸ³ä¹</button>

<div id="notation"></div>

<script>
    // å³æ‰‹éŸ³ç¬¦åºåˆ—
    const finalRightNotes = [
        { pitch: "F#", duration: 0.5 }, { pitch: "F#", duration: 0.125 },
        { pitch: "E", duration: 0.25 }, { pitch: "E", duration: 0.125 },
        { pitch: "E", duration: 0.25 }, { pitch: "E", duration: 0.125 },
        { pitch: "F#", duration: 0.5 }, { pitch: "F#", duration: 0.125 },
        { pitch: "F#", duration: 0.5 }, { pitch: "F#", duration: 0.125 },
        { pitch: "F#", duration: 0.25 }, { pitch: "F#", duration: 0.125 },
        { pitch: "F#", duration: 0.25 }, { pitch: "F#", duration: 0.125 },
        { pitch: "F#", duration: 0.5 }, { pitch: "F#", duration: 0.125 }
    ];

    // Markové“¾ç”Ÿæˆå·¦æ‰‹éŸ³ç¬¦
    const markovChain = {
        "F#": ["D", "A", "B"],
        "E": ["C", "G", "A"],
        "D": ["F#", "B", "G"],
        "C": ["E", "A", "D"]
    };

    function generate_dual_voice_measure(rightNotes) {
        return rightNotes.map(note => {
            const possibleLeftPitches = markovChain[note.pitch] || ["C", "D", "E"];
            const leftPitch = possibleLeftPitches[Math.floor(Math.random() * possibleLeftPitches.length)];
            return { pitch: leftPitch, duration: note.duration };
        });
    }

    // ç”Ÿæˆå·¦æ‰‹éŸ³ç¬¦åºåˆ—
    const finalLeftNotes = generate_dual_voice_measure(finalRightNotes);

    // æ’­æ”¾éŸ³é¢‘
    function playMusic() {
  // ä½¿ç”¨è‡ªå®šä¹‰åŒ…ç»œå‚æ•°ï¼Œè®©éŸ³ç¬¦æ›´å¿«ç»“æŸ
  const synth = new Tone.PolySynth(Tone.Synth, {
    envelope: {
      attack: 0.005,
      decay: 0.1,
      sustain: 0.3,
      release: 0.1  // ç¼©çŸ­é‡Šæ”¾æ—¶é—´
    }
  }).toDestination();

  let time = Tone.now();

  finalRightNotes.forEach((note, index) => {
    const leftNote = finalLeftNotes[index];

    // å³æ‰‹éŸ³ç¬¦ç«‹å³è§¦å‘
    synth.triggerAttackRelease(note.pitch + "4", note.duration * 0.8, time);
    
    // å·¦æ‰‹éŸ³ç¬¦ç¨å¾®å»¶è¿Ÿ 0.02 ç§’è§¦å‘ï¼Œé¿å…å®Œå…¨é‡å 
    synth.triggerAttackRelease(leftNote.pitch + "3", leftNote.duration * 0.8, time + 0.02);

    // æŒ‰ç…§å³æ‰‹çš„ duration ç´¯åŠ æ—¶é—´
    time += note.duration;
  });
}

    // **ä¿®æ­£åˆ†å°èŠ‚æ–¹æ³•ï¼Œç¡®ä¿ä¸è¶…è¿‡4æ‹**
    function splitIntoMeasures(notes) {
        let measures = [];
        let currentMeasure = [];
        let totalBeats = 0;

        notes.forEach(note => {
            if (totalBeats + note.duration > 4) {
                measures.push(currentMeasure);
                currentMeasure = [];
                totalBeats = 0;
            }
            currentMeasure.push(note);
            totalBeats += note.duration;
        });

        if (currentMeasure.length > 0) {
            measures.push(currentMeasure);
        }

        return measures;
    }

    // è½¬æ¢éŸ³ç¬¦æ ¼å¼
    function convertToVexNotes(notes, clef) {
        return notes.map(note => {
            let duration = (note.duration === 0.125) ? "8" :
                           (note.duration === 0.25) ? "q" :
                           (note.duration === 0.5) ? "h" : "w";

            return new Vex.Flow.StaveNote({
                clef: clef,
                keys: [note.pitch.toLowerCase() + ((clef === "treble") ? "/4" : "/3")],
                duration: duration
            });
        });
    }

    function drawNotation() {
        const VF = Vex.Flow;
        const div = document.getElementById("notation");
        div.innerHTML = ""; // æ¸…é™¤å·²æœ‰çš„äº”çº¿è°±

        const rightMeasures = splitIntoMeasures(finalRightNotes);
        const leftMeasures = splitIntoMeasures(finalLeftNotes);

        rightMeasures.forEach((measure, index) => {
            const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
            renderer.resize(600, 300);
            const context = renderer.getContext();
            const stave = new VF.Stave(10, 40, 550);
            stave.addClef("treble").setContext(context).draw();

            const staveBass = new VF.Stave(10, 140, 550);
            staveBass.addClef("bass").setContext(context).draw();

            const rightHandNotes = convertToVexNotes(measure, "treble");
            const leftHandNotes = convertToVexNotes(leftMeasures[index], "bass");

            const voiceRight = new VF.Voice({ num_beats: 4, beat_value: 4 });
            voiceRight.setStrict(false); // **å…è®¸ä¸æ»¡ 4 æ‹**
            voiceRight.addTickables(rightHandNotes);

            const voiceLeft = new VF.Voice({ num_beats: 4, beat_value: 4 });
            voiceLeft.setStrict(false); // **å…è®¸ä¸æ»¡ 4 æ‹**
            voiceLeft.addTickables(leftHandNotes);

            const formatter = new VF.Formatter().joinVoices([voiceRight, voiceLeft]).format([voiceRight, voiceLeft], 500);
            voiceRight.draw(context, stave);
            voiceLeft.draw(context, staveBass);
        });
    }

    drawNotation();
</script>

</body>
</html>